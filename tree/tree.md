# Tree, Tries

## Contents
- [Tree](#tree)
- [Binary Tree](#binary-tree)
- [Binary Search Tree](#binary-search-tree)
- [Heap](#heap)
- [B-Tree](#b-tree)
- [Trie](#trie)


## Tree

### Basic Concepts
- 한 노드가 여러 노드로의 '링크'를 갖고 있는 형태
- 트리는 부모 노드가 반드시 홀수
- 트리를 만들 땐, 무작위로 정렬된 데이터를 사용해야 균형잡힌 트리가 만들어짐.
    - 부모와 자식 간에 규칙이 있기 때문에, 정렬된 데이터를 사용할 경우 트리 모양으로 안 만들어지기 때문임.
- 용어
    - root node: 최상위 노드
    - parent node: 어떤 노드의 상위 노드
    - child node: 어떤 노드의 하위 노드
    - leaf node(terminal node): child node가 하나도 없는 노드
    - sibling(brother node): 동일한 parent node를 가진 노드
    - level: 트리의 계층(트리의 깊이)
    - depth: 트리의 최대 깊이

### 관련 알고리즘
- 순회; Traversal
    - 전위 순회; Preorder Traversal
        - 자식 노드보다 현재 노드를 먼저 방문하는 방법
        - 부모 -> 왼쪽 자식 -> 오른쪽 자식 순으로 방문
        - 루트 노드를 먼저 처리해야 하는 경우, 트리 재구성 등에 사용
    - 중위 순회; Inorder Traversal
        - 왼쪽 자식 -> 부모 -> 오른쪽 자식 순으로 방문
        - BST 이용한 정렬(중위 순회 결과가 항상 정렬된 배열), 오름차순 데이터 관련 문제에 사용
    - 후위 순회; Postorder Traversal
        - 모든 자식 노드들을 먼저 방문한 뒤 마지막에 현재 노드를 방문하는 방법
        - 왼쪽 자식 -> 오른쪽 자식 -> 부모 순으로 방문
        - 각 서브트리 노드의 합 구하기 문제
    - 정리하면 다음과 같음.
    ```bash
            10       # 전위: 10 → 5 → 2 → 1 → 7 → 15 → 12 → 13 → 20
           /  \      # 중위: 1 → 2 → 5 → 7 → 10 → 12 → 13 → 15 → 20
         5     15    # 후위: 1 → 2 → 7 → 5 → 13 → 12 → 20 → 15 → 10
        / \    / \
       2   7  12  20
      /     \
     1      13
    ```
    - [참고 링크](https://hongku.tistory.com/160)


## Binary Tree

### Basic Concepts
- 각 노드가 0에서 최대 2개의 자식을 갖는 트리
- Big O
    - 트리의 종류에 상관 없이 거의 동일
        - perfect binary tree만 삽입 시 O(n)인데, 트리를 재구성해야 하기 때문임.
    - 공간 복잡도: O(n)
    - 시간 복잡도(탐색, 삽입, 삭제)
        - 평균: O(log n)
        - 최악: O(n)

### Basic Types
- 완전 이진 트리; complete binary tree
    - 말단 노드를 제외한 모든 노드가 자식을 2개씩 갖고 있는 트리
    - 말단 노드의 부모는 2개 안 갖고 있어도 되는데, 자식이 1개인 경우엔 왼쪽부터 채워져 있어야 함.
- 포화 이진 트리; perfect binary tree
    - 말단 노드를 제외한 모든 노드가 자식을 2개씩 갖고 있는 트리
    - 모든 말단 노드는 같은 높이에 있어야 함.
    - 말단 노드가 위치한 레벨에서 노드의 개수가 최대가 되어야 함.
    - 포화 이진 트리의 노드 개수는 `2^k-1`(k는 트리의 높이)
- 전 이진 트리; full binary tree
    - 모든 노드의 자식이 0 또는 2개 있는 경우를 말함.
    - 즉, 자식이 1개만 있는 노드가 없는 경우임.
- 균형 이진 트리; balanced binary tree
    - 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하인 트리

## Binary Search Tree
- 탐색에 특화된 이진 트리의 일종
- `left < parent < right` 라는 규칙을 가짐.
    - 즉, 부모 값이 중간값
    - 이건 모든 서브트리에서도 충족되어야 하며, 예를 들어 이하의 경우는 BST가 아님.
    - 왜냐면 5의 왼쪽 자식 중에 4가 있기 때문
        ```bash
            5
           / \
          1   7
             / \
            4   8
        ```
- 중복값을 허용하지 않음.
- 탐색 시, 균형잡혔을 땐 O(log n) 이지만 불균형할 땐 O(n) 까지 성능이 떨어짐.
    - 이 때문에 자동으로 균형을 잡는 heap 쪽이 데이터 검색에 더 유리한 경우가 있음.
- 이 단점을 보완한 BST가 AVL 트리, Red-Black 트리

### 관련 알고리즘
- 중위 순회; Inorder Traversal
    - BST에서 중위 순회를 하면, 오름차순으로 탐색을 하게 됨.
    - 재귀 또는 반복문+스택으로 구현 가능
    - 시간 복잡도
        - 최악(불균형한 트리): O(N)
        - 최선(균형잡힌 트리): O(log N)
    - 공간 복잡도: O(N)


## Heap

### Basic Concepts
- complete binary tree의 일종으로 탐색에 특화되었음.
- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 작은 상태를 유지해야 함.
    - 즉, 부모가 최대/최소값
- 값이 왼쪽 자식부터 채워져야 함.
- 힙 트리에서는 중복된 값을 허용함.
- 최대값이나 최소값을 빠르게 찾아낼 수 있음.
- 우선순위 큐; Priority Queue를 만들 때 자주 쓰이는 자료구조 (자세한 건 큐 참고)

### 종류
- 최대 힙; Max Heap
    - 부모 노드의 값 >= 양쪽 자식 노드의 값
    - 자식 노드 간의 크고 작음은 신경 안 씀.
- 최소 힙; Min Heap
    - 부모 노드의 값 <= 양쪽 자식 노드의 값
    - 자식 노드 간의 크고 작음은 신경 안 씀.

### heap sort
- 시간복잡도 기준
    - 생성: O(N)
    - 정렬: O(N log N) (평균, 최악 전부 그런 듯)
        - 병합정렬(merge sort)이 같은 시간복잡도를 갖는데, heap sort의 공간 복잡도는 O(1) 이라 메모리를 덜 씀.
        - 정렬할 때, 힙에 원소를 삽입하면서 힙 구조를 만들어나가면서 하기 때문에 N이 더 붙은 것
- k번째 큰 수 찾기, 우선순위 큐 구현, 메모리 제약 있는 대규모 데이터 정렬 등에 사용하기 좋음.

### 구현
- 기본적으로 배열로 구현
- 배열의 뒤 절반은 자식이 없는 리프 노드임.
    - 그래서 임의의 배열을 heapify로 heap 만들고자 한다면, 해당 배열의 절반(len / 2)만큼만 for문 돌아야 함.
- 배열에서 이진트리 노드 인덱스 찾기
    - 0-based 배열인 경우
        - 왼쪽 자식 노드의 인덱스: `parent_idx * 2 + 1`
        - 오른쪽 자식 노드의 인덱스: `parent_idx * 2 + 2`
        - 부모 노드의 인덱스: `(child_idx - 1) / 2`
    - 1-based 배열인 경우
        - 1-based 배열은 구현을 쉽게 하기 위해 0번 인덱스를 안 씀.
            - `example.go`의 `MinHeap`이 여기에 해당됨.
        - 왼쪽 자식 노드의 인덱스: `parent_idx * 2`
        - 오른쪽 자식 노드의 인덱스: `parent_idx * 2 + 1`
        - 부모 노드의 인덱스: `child_idx/2 `
    - 배열로 구현할 때 이런 공식을 쓰는 이유
        - 0번째(또는 1번째) 인덱스부터 값을 차례로 넣기 위한 것
        - 예를 들어, 부모 노드가 0 이라면, 1이랑 2가 자식 노드가 되고, 그 다음 1의 자식 노드는 3, 4가 되고, 2의 자식 노드는 5, 6이 됨.
- heap 만들 때 필요한 메서드
    - `down_heap`
        - 루트 노드의 값을 자식 노드와 비교하면서 그 값이 맞는 자리를 찾을 때까지 그 값을 계속 내림. (root -> leaf)
        - heap 에서 요소를 삭제(Pop)할 때 사용함.
        - 이 메서드의 시간 복잡도는 O(log N)
        - 알고리즘 문제에서는 이 메서드만 사용하는 경우가 있음. (heapify 라는 이름으로..)
            - 입력된 모든 데이터를 확인해야 하는 경우
            - 주어진 배열을 한 번에 힙으로 변환해서 사용해야 한다든지.
            - 이미 정렬되어 온 데이터로 힙을 구성한 후 k번째로 작은/큰 값 찾아야 한다든지
            - 특히 입력된 데이터의 크기가 작을 때 괜찮음.
            - 예를 들어, 모든 조합을 평가한 후에 k개를 추출한다든지
     - `up_heap`
        - 새 값을 가장 마지막 자식 노드에 넣고, 부모와 비교하면서 자리를 찾을 때 까지 그 값을 위로 올림. (leaf -> root)
        - heap에 요소를 삽입(Push)할 때 사용함.
        - 이 메서드의 시간 복잡도는 O(log N)
        - 대부분의 heap 문제에서 `down_heap`이랑 함께 사용됨.
            - 이거 같이 쓰면 heap을 일정 크기로 유지할 수 있고, 전체 데이터를 순회하지 않아도 됨.
            - 그래서 입력 데이터가 클 때 `down_heap`만 사용하는 것보다 훨씬 효율적임.
            - 예를 들어, 최소 k개의 데이터만 찾기 위해 힙 크기를 k개로 유지하면서 작업할 때
- golang 에서는 `container/heap` 를 이용할 수 있음.
    - 이거 쓸 때 heap 은 배열로 구성해줘야 하고, `Len()`, `Less()`, `Swap()`, `Empty()`, `Push()`, `Pop()` 구현해줘야 함.

### 참고
- [[자료구조] 힙(heap이란)](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)
- LeetCode


## B-Tree
- 이진 트리의 일종
    - B는 무슨 의미인지는 명확하지 않고, 보통 Balanced 나 Bayer(처음 제안한 과학자 중 한명)의 B로 생각한다는 듯
- 트리 내의 데이터의 삽입/삭제가 발생해도 그 균형을 최대한 유지함.
   - 다른 트리 구조에 비해서 삽입/삭제 시에 균형을 유지하도록 설계되었기 때문
   - 비슷하게 Balanced Binary Search Tree 종류가 자동으로 균형을 유지한다는 듯(e.g., AVL, Red-Black 등)
- 이거 업글 버전인 B+ 트리가 RDB의 자료구조로 많이 쓰임.
- 주요 특징
    - 노드 내에 데이터를 여러 개 가질 수 있음.
    - 어느 부모 노드의 데이터가 N개일 때 자식 노드의 데이터 개수는 N+1 임.
    - +1 이 되는 이유는 삽입 과정에서 발생하는 노드 분열 때문인 듯
        - 3차 B 트리, 홀수 차수인 경우 예시를 봐보자.
        - 부모 노드는 2개의 데이터 자리가 있을 것
        - 거기에 데이터가 꽉 차있는 상태인데, 새로운 데이터를 넣는다 치자.
        - 부모 노드를 분열을 시키고, 부모 노드의 데이터들과 새로 넣으려고 하는 데이터를 비교
        - 그 중 중간값을 부모 노드 자리에 넣고, 나머지 값들은 새로운 자식 노드를 만들어서 거기에 데이터를 넣어줌.
        - 근데 만약 새로 만든 노드에 빈 공간이 하나 뿐이라면, 분열시킨 데이터들이 자리를 다 차지하고 들어가서 이후에 새로운 데이터를 또 받을 수 없게 됨.
        - 그래서 새롭게 만든 노드들한테 +1개의 빈 공간을 주는 것
- 용어
    - N차 트리
        - 자식 노드의 데이터를 N개 갖는 트리를 일컫는 것
        - 예를 들어, 부모가 3개라면 자식 노드는 4개가 될텐데, 이 경우 4차 B 트리라고 말함.
- 참고문제
    - LeetCode '1382. Balance a Binary Search Tree'
        - inorder traversal로 트리를 탐색해서 값들을 배열에 차례로 넣고,
        - 배열 중간값을 노드값으로, 배열 중간의 왼쪽 값들은 Left 노드로, 오른쪽 값들은 Right 노드로 넣음.
        - inorder 를 사용하는 이유는 부모값이 중간에 위치하게 해주기 때문이라는 듯
- 참고
    - [[자료구조] B 트리](https://mommoo.tistory.com/108)


## Trie
- 문자열을 효율적으로 저장하고 검색하기 위해 특화된 이진 트리의 일종
    - prefix tree 라고도 불림.
- 한 노드에 문자 하나 저장
  - 트리를 아래쪽으로 순회하면 단어가 하나 나옴.
  - 즉, 사전같은 느낌.
- 단어가 끝나는 지점을 나타내는 플래그(`isEnd` 같은)를 가지는데, 이걸 EOW; End Of Word 라고 말함.
- 문자열 패턴 검색이 중요한 경우에 사용
  - e.g., 문자열 검색, 자동 완성, 사전, IP 라우팅 등
- 시간 복잡도(검색/삽입/삭제): O(n)
- 공간 복잡도: ? 단순 배열이나 해시 테이블보다도 메모리 사용량이 많음.